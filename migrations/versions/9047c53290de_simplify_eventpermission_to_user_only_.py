"""Simplify EventPermission to user-only access

Revision ID: 9047c53290de
Revises: f54bc5e16af3
Create Date: 2025-09-25 14:39:34.378234

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '9047c53290de'
down_revision = 'f54bc5e16af3'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('event_permission', schema=None) as batch_op:
        # Step 1: Drop all old constraints and indices that are no longer valid or might conflict
        # Use try-except blocks for robustness, as some might already be gone depending on DB state.

        # CRUCIAL FIX: Drop the CHECK constraint that references 'group_id'
        # This constraint was causing the 'no such column: group_id' error during table recreation.
        try:
            # The name of the CHECK constraint was '_user_or_group_check' in models.py
            batch_op.drop_constraint('_user_or_group_check', type_='check')
            print("DEBUG: Dropped CHECK constraint '_user_or_group_check'.")
        except Exception as e:
            print(f"DEBUG: CHECK constraint '_user_or_group_check' not found or error dropping: {e} (might be normal if already removed).")

        # Drop foreign keys first before dropping columns
        try:
            batch_op.drop_constraint('fk_event_permission_group_id', type_='foreignkey')
            print("DEBUG: Dropped foreign key 'fk_event_permission_group_id'.")
        except Exception as e:
            print(f"DEBUG: Foreign key 'fk_event_permission_group_id' not found or error dropping: {e} (might be normal).")

        try:
            batch_op.drop_constraint('fk_event_permission_role_id', type_='foreignkey')
            print("DEBUG: Dropped foreign key 'fk_event_permission_role_id'.")
        except Exception as e:
            print(f"DEBUG: Foreign key 'fk_event_permission_role_id' not found or error dropping: {e} (might be normal).")

        # Drop indices
        try:
            # batch_op.f() retrieves Alembic's auto-generated names.
            batch_op.drop_index(batch_op.f('_event_group_unique_idx'))
            print("DEBUG: Dropped index '_event_group_unique_idx'.")
        except Exception as e:
            print(f"DEBUG: Index '_event_group_unique_idx' not found or error dropping: {e} (might be normal).")

        try:
            batch_op.drop_index(batch_op.f('_event_user_unique_idx'))
            print("DEBUG: Dropped index '_event_user_unique_idx'.")
        except Exception as e:
            print(f"DEBUG: Index '_event_user_unique_idx' not found or error dropping: {e} (might be normal).")


        # Step 2: Drop the columns
        try:
            batch_op.drop_column('group_id')
            print("DEBUG: Dropped column 'group_id'.")
        except Exception as e:
            print(f"DEBUG: Column 'group_id' not found or error dropping: {e} (might be normal if already removed).")

        try:
            batch_op.drop_column('role_id')
            print("DEBUG: Dropped column 'role_id'.")
        except Exception as e:
            print(f"DEBUG: Column 'role_id' not found or error dropping: {e} (might be normal if already removed).")


        # Step 3: Alter 'user_id' column to be NOT NULL
        # It's important to specify existing_nullable=True if 'user_id' was nullable before.
        # This helps Alembic handle the change gracefully, especially in SQLite batch mode.
        batch_op.alter_column('user_id',
                              existing_type=sa.INTEGER(),
                              nullable=False,
                              existing_nullable=True) # Explicitly state previous nullable state for robustness
        print("DEBUG: Altered column 'user_id' to NOT NULL.")


        # Step 4: Create the new unique constraint (name must match models.py)
        # Ensure the name matches the one in models.py: '_event_user_unique_uc'
        batch_op.create_unique_constraint('_event_user_unique_uc', ['event_id', 'user_id'])
        print("DEBUG: Created unique constraint '_event_user_unique_uc'.")

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('event_permission', schema=None) as batch_op:
        batch_op.add_column(sa.Column('role_id', sa.INTEGER(), nullable=False))
        batch_op.add_column(sa.Column('group_id', sa.INTEGER(), nullable=True))
        batch_op.create_foreign_key(batch_op.f('fk_event_permission_role_id'), 'role', ['role_id'], ['id'])
        batch_op.create_foreign_key(batch_op.f('fk_event_permission_group_id'), 'group', ['group_id'], ['id'], ondelete='CASCADE')
        batch_op.drop_constraint('_event_user_unique_uc', type_='unique') # Note: using the new constraint name created in upgrade
        batch_op.create_index(batch_op.f('_event_user_unique_idx'), ['event_id', 'user_id'], unique=1)
        batch_op.create_index(batch_op.f('_event_group_unique_idx'), ['event_id', 'group_id'], unique=1)
        batch_op.alter_column('user_id',
               existing_type=sa.INTEGER(),
               nullable=True,
               existing_nullable=False) # Important: specify existing_nullable for downgrade too

        # Re-add the CHECK constraint '_user_or_group_check'
        # Note: SQLite batch mode might handle this implicitly on recreation, but good to be explicit.
        # This constraint was: (user_id IS NOT NULL AND group_id IS NULL) OR (user_id IS NULL AND group_id IS NOT NULL)
        # However, alembic doesn't have a direct op.create_check_constraint.
        # If this causes issues on downgrade, it might need to be a raw SQL op.
        # For now, let's assume alembic's auto-generated downgrade for batch_alter_table will handle check constraints implicitly if they were there.
        # If _user_or_group_check was dropped in upgrade, it generally needs to be recreated here.
        # Given SQLite's limitations, this might be a point of manual adjustment if downgrade fails.
        # For now, leaving it as Alembic would typically infer, but adding a note.
        print("DEBUG: If downgrade fails due to missing CHECK constraint, it might need manual addition here.")

    # ### end Alembic commands ###